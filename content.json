[{"title":"Git manual","date":"2017-01-22T16:00:00.000Z","path":"2017/01/23/Git manual/","text":"常用操作$ git branch -vv[l/a] 查看branch[本地/与origin分支] $ git push origin master 提交本地修改 $ git checkout release 切换到本地 release 分支 $ git pull origin release 更新本地库中的 origin/release 分支且合并到本地 release 分支 $ git log --graph --pretty=oneline --abbrev-commit 查看日志 基本概念Git 分为 工作区 (Working Directory) 、暂存区 (Stage) 和 版本库 (Repository) Git 管理的是修改，NOT 文件; Git 在远端和本地各维护着一个代码库; 初始化Git仓库 和 添加\\提交文件初始化一个Git仓库，使用 git init 命令。 添加文件到Git仓库，分两步： 第一步，使用命令 git add ，注意，可反复多次使用，添加多个文件； 第二步，使用命令 git commit ，完成。 查看状态 git status 和 git diff要随时掌握工作区的状态，使用 git status 命令。 如果 git status 告诉你有文件被修改过，用 git diff [--staged] 可以查看修改内容。 版本回退 git resetHEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令 git reset --hard commit_id 。 穿梭前，用 git log 可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用 git reflog 查看命令历史，以便确定要回到未来的哪个版本。 查看日志日志简写 git log --pretty=oneline --abbrev-commit 日志跟踪 git log --graph --pretty=oneline --abbrev-commit 撤销修改场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令 git checkout -- file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步: 第一步用命令 git reset HEAD file，就回到了场景1; 第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 git checkoutgit checkout -- readme.txt 意思就是，把 readme.txt 文件在工作区的修改全部撤销，这有两种情况： 一种是 readme.txt 自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态; 一种是 readme.txt 已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次 git commit 或 git add 时的状态。 $ git checkout -- readme.txt git resetgit reset HEAD file 可以把暂存区的修改撤销掉（unstage），重新放回工作区： $ git reset HEAD readme.txt Unstaged changes after reset: M readme.txt git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。 删除文件$ rm test.txt $ git rm test.txt $ git commit -m &quot;remove test.txt&quot; git rm 用于删除一个文件。如果这个文件已经被提交到版本库，那么你永远不用担心误删， 但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。 首次关联和推送$ git remote add origin https://github.com/&lt;git_name&gt;/&lt;git_repos_name&gt;.git [ OR $ git remote add origin git@github.com:&lt;git_name&gt;/&lt;git_repos_name&gt;.git ] $ git push -u origin master PS: Git支持多种协议，包括https，但通过ssh支持的原生git协议速度最快。 switch to git : $ git remote rm origin $ git remote add origin git@github.com:&lt;git_name&gt;/&lt;git_repos_name&gt;.git 提交From now on, 只要本地作了提交，就可以通过命令： $ git push origin master Branch 管理创建并切换到分支 $ git checkout -b dev == $ git branch dev $ git checkout dev 查看分支 $ git branch $ git branch -r $ git branch -a $ git branch -vv 切换到 master 分支 $ git checkout master 合并 dev 分支修改到 当前 分支 $ git merge dev 删除 dev 分支 $ git branch -d dev Branch 更新$ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; 取回 origin 主机的 next 分支，与本地的 master 分支合并: $ git pull origin next:master 如果远程分支是与当前分支合并，则冒号后面的部分可以省略: $ git pull origin next == $ git fetch origin $ git merge origin/next $ git pull origin master == $ git fetch origin master 从远程的 origin 的 master 主分支下载最新的版本到 origin/master 分支上 $ git log -p master..origin/master 比较本地的 master 分支和 origin/master 分支的差别 $ git merge origin/master 合并到当前分支 == $ git fetch origin master:tmp $ git diff tmp $ git merge tmp 更新某个文件 $ git fetch origin card [update本地库中的 origin/card 分支] $ git checkout origin/card -- &lt;path/to/file&gt; [获取本地库中的 origin/card 分支的某个文件到本地 card 分支] Tag 管理在最新 commit 上打 tag $ git tag v1.0 在某个 commit id 上打 tag $ git tag v0.5 &lt;commit_id&gt; $ git tag -a v0.5 [-m &lt;msg&gt;] &lt;commit_id&gt; 查看 tag $ git tag $ git show &lt;tag_name&gt; 删除某个 tag $ git tag -d &lt;tag_name&gt; 推送某个 tag 到 remote $ git push origin v1.0","tags":[{"name":"git","slug":"git","permalink":"http://walter-du.io/tags/git/"}]},{"title":"UDP Q&A","date":"2017-01-21T16:00:00.000Z","path":"2017/01/22/UDP Q&A/","text":"UDP 发送大包会发生什么? UDP 不存在发送缓冲区; 套接口选项 ‘SO_SNDBUF’ 可用来设置允许 write 的 UDP 数据报大小的上限,超出则返回 EMSGSIZE ; UDP 层传到 IP 层,IP 层传到链路层时,如果大于 MTU 则会导致分片; UDP write 若能成功返回,则说明 UDP 数据报(或其分片片段)一路向下,已加入到链路层队列。 UDP 发包过快会发生什么？对端会如何处理？ 对于发送端,发送过快,发送端的 NIC 的 DMA ring 来不及消耗(从 NIC 发出), DMA ring 用完,通常会 stop 发送软中断,即停止链路层的输出队列 skb 出队,进而输出队列满,返回 ENOBUFS; 对于接收端,接收过快(NIC 能力范围内),导致 UDP 的接收缓冲区满(应用进程未及时读),则 UDP 直接将收到的数据报丢弃; 对于接收端,若实在太快导致 NIC 的接收中断 overflow error, NIC 已无力回天,显然报文就会默默的消失。 UDP 是否需要绑定源端口? 可以 bind,但不是必须的; 未 bind 直接 sendto 的话, UDP 会自动选择一个 PORT 然后将其置为绑定状态。 UDP 为何是无连接的(connectionless)？ 发送端和接收端不必存在长期的关系。 UDP 何为有边界记录？ 每个 UDP 数据报都有一个长度,其长度值会直接传给接收端。 UDP 数据报一次 read 未读完,是否还能继续读完？ 每个 UDP 数据报都有一个长度,通常应用进程 write 时应保证这个长度小于 MTU 以避免分片; 应用进程 read UDP 数据报时,应尽可能一次读完一整个 UDP 数据报; 即 readmsg 中设置的 buf’s nbytes &gt;= sizeof (UDP 数据报); 因为每个 UDP 数据报是以一个整体 skb 出队的,一次 read 不完的话这个 skb 中剩余的 data 会被丢弃,并且会返回 msg-&gt;msg_flags |= MSG_TRUNC; 12345copied = skb-&gt;len - sizeof(struct udphdr);if (copied &gt; len) &#123; copied = len; msg-&gt;msg_flags |= MSG_TRUNC;&#125; 如果 readmsg 中 flags 设置了 MSG_TRUNC,则不管 readmsg 实际读取了多少 nbytes,其返回值总是为整个 UDP 数据报的长度: 12if (flags &amp; MSG_TRUNC) err = skb-&gt;len - sizeof(struct udphdr); PS: Refer to ‘udp.c‘ – ‘udp_recvmsg()‘. UDP 为何不可靠？ 数据报出错(丢失,参见上)后无重传机制。 UDP 适用什么场景？ 广播或多播; 少量的数据传输,简答的请求-应答交互; 尽量可靠的网络,如局域网。 UDP 与 “两军问题” ？ BAIDU 或 GOOGLE UDP 与 ‘SO_REUSEADDR’ 和 ‘SO_REUSEPORT’ UDP 允许完全重复的绑定: 同 IP 和 同端口绑定到多个套接字; TCP 则不完全支持。 PS: Refer to “UNIX Network Programming VOLUME 1” Page 179. SS 是否支持封装(encapsulate) UDP 报文? Socks4 不支持, Socks5 支持 UDP;","tags":[{"name":"network","slug":"network","permalink":"http://walter-du.io/tags/network/"}]},{"title":"Ssh-tunnel AND SS","date":"2017-01-21T16:00:00.000Z","path":"2017/01/22/Ssh-tunnel AND SS/","text":"On-Top update ‘hosts’ update ‘g~f~wlist’ Tools Windows 自带 MD5 命令: certutil -hashfile MD5 ; ‘ssh’/‘netcat’(nc,支持明文或其他加密) 都能实现简单的端口转发功能; eg: 查看某 server 是否开启 80 端口: # nc &lt;server’s ip&gt; 80 (strace 或 tcpdump 查看报文交互) ‘dig’ for lookup ; 单一的 ssh-tunnel 由于 ssh 本身就是基于 RSA 加密技术,所以 G~F~W 无法从数据传输的过程中对加密数据内容进行关键词分析,避免了被重置链接的问题; 但由于创建隧道和数据传输的过程中, ssh 本身的特征是明显的,所以 G~F~W 可以通过分析连接的特征进行干扰,导致 ssh 存在被定向进行干扰的问题。 SS 简单理解的话, SS 是将原来 ssh 创建的 Socks5 协议拆开成 server 端和 client 端,其原理基本上和利用 ssh-tunnel 大致类似: 1.客户端发出的请求基于 Socks5 协议跟 ss-local 端进行通讯,由于这个 ss-local 一般是本机或路由器或局域网的其他机器,不经过 G~F~W ,所以解决了上面被 G~F~W 通过特征分析进行干扰的问题; 2.ss-local 和 ss-server 两端通过多种可选的加密方法进行通讯,经过 G~F~W 的时候是常规的 TCP 包,没有明显的特征码且 G~F~W 也无法对通讯数据进行解密; 3.ss-server 将收到的加密数据进行解密,还原原来的请求,再发送到用户需要访问的服务,获取响应原路返回。 两条 DNS 查询链： 国外：Client—ChinaDNS—dnsmasq—SS—代理Server—GoogleDNS国内：Client—ChinaDNS—114DNS","tags":[{"name":"network","slug":"network","permalink":"http://walter-du.io/tags/network/"},{"name":"SS","slug":"SS","permalink":"http://walter-du.io/tags/SS/"}]}]