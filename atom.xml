<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Simply this</title>
  <subtitle>That is exactly what I&#39;m saying.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://walter-du.io/"/>
  <updated>2017-01-23T07:00:00.802Z</updated>
  <id>http://walter-du.io/</id>
  
  <author>
    <name>walter-du</name>
    <email>walter-du@outlook.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Ssh-tunnel AND SS</title>
    <link href="http://walter-du.io/2017/01/22/Ssh-tunnel%20AND%20SS/"/>
    <id>http://walter-du.io/2017/01/22/Ssh-tunnel AND SS/</id>
    <published>2017-01-21T16:00:00.000Z</published>
    <updated>2017-01-23T07:00:00.802Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h2 id="On-Top"><a href="#On-Top" class="headerlink" title="On-Top"></a>On-Top</h2><ul>
<li>update ‘hosts’</li>
<li>update ‘g~f~wlist’</li>
</ul>
<h2 id="Tools"><a href="#Tools" class="headerlink" title="Tools"></a>Tools</h2><ul>
<li>Windows 自带 MD5 命令: certutil -hashfile <filename> MD5 ;</filename></li>
<li>‘ssh’/‘netcat’(nc,支持明文或其他加密) 都能实现简单的端口转发功能;<br>  eg:<blockquote>
<p>查看某 server 是否开启 80 端口: # nc &lt;server’s ip&gt; 80 (strace 或 tcpdump 查看报文交互)</p>
</blockquote>
</li>
<li>‘dig’ for lookup ;</li>
</ul>
<h2 id="单一的-ssh-tunnel"><a href="#单一的-ssh-tunnel" class="headerlink" title="单一的 ssh-tunnel"></a>单一的 ssh-tunnel</h2><ul>
<li>由于 ssh 本身就是基于 RSA 加密技术,所以 G~F~W 无法从数据传输的过程中对加密数据内容进行关键词分析,避免了被重置链接的问题;</li>
<li>但由于创建隧道和数据传输的过程中, ssh 本身的特征是明显的,所以 G~F~W 可以通过分析连接的特征进行干扰,导致 ssh 存在被定向进行干扰的问题。</li>
</ul>
<h2 id="SS"><a href="#SS" class="headerlink" title="SS"></a>SS</h2><ul>
<li><p>简单理解的话, SS 是将原来 ssh 创建的 Socks5 协议拆开成 server 端和 client 端,其原理基本上和利用 ssh-tunnel 大致类似:<br>  1.客户端发出的请求基于 Socks5 协议跟 ss-local 端进行通讯,由于这个 ss-local 一般是本机或路由器或局域网的其他机器,不经过 G~F~W ,所以解决了上面被 G~F~W 通过特征分析进行干扰的问题;<br>  2.ss-local 和 ss-server 两端通过多种可选的加密方法进行通讯,经过 G~F~W 的时候是常规的 TCP 包,没有明显的特征码且 G~F~W 也无法对通讯数据进行解密;<br>  3.ss-server 将收到的加密数据进行解密,还原原来的请求,再发送到用户需要访问的服务,获取响应原路返回。</p>
<p>  两条 DNS 查询链：</p>
<blockquote>
<p>国外：Client—ChinaDNS—dnsmasq—SS—代理Server—GoogleDNS<br>国内：Client—ChinaDNS—114DNS</p>
</blockquote>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      Ssh-tunnel, SS
    
    </summary>
    
      <category term="network" scheme="http://walter-du.io/categories/network/"/>
    
    
      <category term="network" scheme="http://walter-du.io/tags/network/"/>
    
      <category term="SS" scheme="http://walter-du.io/tags/SS/"/>
    
  </entry>
  
  <entry>
    <title>UDP Q&amp;A</title>
    <link href="http://walter-du.io/2017/01/22/UDP%20Q&amp;A/"/>
    <id>http://walter-du.io/2017/01/22/UDP Q&amp;A/</id>
    <published>2017-01-21T16:00:00.000Z</published>
    <updated>2017-01-23T06:57:47.504Z</updated>
    
    <content type="html"><![CDATA[<hr>
<h2 id="UDP-发送大包会发生什么"><a href="#UDP-发送大包会发生什么" class="headerlink" title="UDP 发送大包会发生什么?"></a>UDP 发送大包会发生什么?</h2><ul>
<li>UDP 不存在发送缓冲区;</li>
<li>套接口选项 ‘SO_SNDBUF’ 可用来设置允许 write 的 UDP 数据报大小的上限,超出则返回 EMSGSIZE ;</li>
<li>UDP 层传到 IP 层,IP 层传到链路层时,如果大于 MTU 则会导致分片;</li>
<li>UDP write 若能成功返回,则说明 UDP 数据报(或其分片片段)一路向下,已加入到链路层队列。</li>
</ul>
<h2 id="UDP-发包过快会发生什么？对端会如何处理？"><a href="#UDP-发包过快会发生什么？对端会如何处理？" class="headerlink" title="UDP 发包过快会发生什么？对端会如何处理？"></a>UDP 发包过快会发生什么？对端会如何处理？</h2><ul>
<li>对于发送端,发送过快,发送端的 NIC 的 DMA ring 来不及消耗(从 NIC 发出), DMA ring 用完,通常会 stop 发送软中断,即停止链路层的输出队列 skb 出队,进而输出队列满,返回 ENOBUFS;</li>
<li>对于接收端,接收过快(NIC 能力范围内),导致 UDP 的接收缓冲区满(应用进程未及时读),则 UDP 直接将收到的数据报丢弃;</li>
<li>对于接收端,若实在太快导致 NIC 的接收中断 overflow error, NIC 已无力回天,显然报文就会默默的消失。</li>
</ul>
<h2 id="UDP-是否需要绑定源端口"><a href="#UDP-是否需要绑定源端口" class="headerlink" title="UDP 是否需要绑定源端口?"></a>UDP 是否需要绑定源端口?</h2><ul>
<li>可以 bind,但不是必须的;</li>
<li>未 bind 直接 sendto 的话, UDP 会自动选择一个 PORT 然后将其置为绑定状态。</li>
</ul>
<h2 id="UDP-为何是无连接的-connectionless-？"><a href="#UDP-为何是无连接的-connectionless-？" class="headerlink" title="UDP 为何是无连接的(connectionless)？"></a>UDP 为何是无连接的(connectionless)？</h2><ul>
<li>发送端和接收端不必存在长期的关系。</li>
</ul>
<h2 id="UDP-何为有边界记录？"><a href="#UDP-何为有边界记录？" class="headerlink" title="UDP 何为有边界记录？"></a>UDP 何为有边界记录？</h2><ul>
<li>每个 UDP 数据报都有一个长度,其长度值会直接传给接收端。</li>
</ul>
<h2 id="UDP-数据报一次-read-未读完-是否还能继续读完？"><a href="#UDP-数据报一次-read-未读完-是否还能继续读完？" class="headerlink" title="UDP 数据报一次 read 未读完,是否还能继续读完？"></a>UDP 数据报一次 read 未读完,是否还能继续读完？</h2><ul>
<li>每个 UDP 数据报都有一个长度,通常应用进程 write 时应保证这个长度小于 MTU 以避免分片;</li>
<li>应用进程 read UDP 数据报时,应尽可能一次读完一整个 UDP 数据报;</li>
<li>即 readmsg 中设置的 buf’s nbytes &gt;= sizeof (UDP 数据报);</li>
<li><p>因为每个 UDP 数据报是以一个整体 skb 出队的,一次 read 不完的话这个 skb 中剩余的 data 会被丢弃,并且会返回 <code>msg-&gt;msg_flags |= MSG_TRUNC</code>;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">copied = skb-&gt;len - sizeof(struct udphdr);</div><div class="line">if (copied &gt; len) &#123;</div><div class="line">    copied = len;</div><div class="line">    msg-&gt;msg_flags |= MSG_TRUNC;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>如果 readmsg 中 flags 设置了 MSG_TRUNC,则不管 readmsg 实际读取了多少 nbytes,其返回值总是为整个 UDP 数据报的长度:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if (flags &amp; MSG_TRUNC)</div><div class="line">    err = skb-&gt;len - sizeof(struct udphdr);</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>PS</strong>:  Refer to ‘<em>udp.c</em>‘ – ‘<em>udp_recvmsg()</em>‘.</p>
</blockquote>
</li>
</ul>
<h2 id="UDP-为何不可靠？"><a href="#UDP-为何不可靠？" class="headerlink" title="UDP 为何不可靠？"></a>UDP 为何不可靠？</h2><ul>
<li>数据报出错(丢失,参见上)后无重传机制。</li>
</ul>
<h2 id="UDP-适用什么场景？"><a href="#UDP-适用什么场景？" class="headerlink" title="UDP 适用什么场景？"></a>UDP 适用什么场景？</h2><ul>
<li>广播或多播;</li>
<li>少量的数据传输,简答的请求-应答交互;</li>
<li>尽量可靠的网络,如局域网。</li>
</ul>
<h2 id="UDP-与-“两军问题”-？"><a href="#UDP-与-“两军问题”-？" class="headerlink" title="UDP 与 “两军问题” ？"></a>UDP 与 “两军问题” ？</h2><ul>
<li>BAIDU 或 GOOGLE</li>
</ul>
<h2 id="UDP-与-‘SO-REUSEADDR’-和-‘SO-REUSEPORT’"><a href="#UDP-与-‘SO-REUSEADDR’-和-‘SO-REUSEPORT’" class="headerlink" title="UDP 与 ‘SO_REUSEADDR’ 和 ‘SO_REUSEPORT’"></a>UDP 与 ‘SO_REUSEADDR’ 和 ‘SO_REUSEPORT’</h2><ul>
<li>UDP 允许完全重复的绑定: 同 IP 和 同端口绑定到多个套接字;</li>
<li>TCP 则不完全支持。<blockquote>
<p><strong>PS</strong>: Refer to <em>“UNIX Network Programming VOLUME 1”</em> Page 179.</p>
</blockquote>
</li>
</ul>
<h2 id="SS-是否支持封装-encapsulate-UDP-报文"><a href="#SS-是否支持封装-encapsulate-UDP-报文" class="headerlink" title="SS 是否支持封装(encapsulate) UDP 报文?"></a>SS 是否支持封装(encapsulate) UDP 报文?</h2><ul>
<li>Socks4 不支持, Socks5 支持 UDP;</li>
</ul>
]]></content>
    
    <summary type="html">
    
      UDP Q&amp;A
    
    </summary>
    
      <category term="network" scheme="http://walter-du.io/categories/network/"/>
    
    
      <category term="network" scheme="http://walter-du.io/tags/network/"/>
    
  </entry>
  
</feed>
